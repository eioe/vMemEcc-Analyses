---
title: "VME Analysis_R manuscript"
author: "Felix Klotzsche, Sven Ohl"
date: "8 6 2021"
output:
  html_document:
    code_folding: hide

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Intro
This file prints relevant statistics and plots of the vMemEcc manuscript. Please note, analyses and plots produced in Python are not included here - but in a separate notebook. The most relevant chunkcs of the source code are included in this file as well. For the full code base, please refer to the [repository on GitHub](https://github.com/eioe/vMemEcc-Analyses). 

## Requirements
We ran these analyses using version 4.1.0 (2021-05-18) in RStudio v1.4.1717. 

## Init workspace
Loads packages, custom functions, custom themes, and data. 
Data is made availbale in the workspace as data frame `data_behav`.  

* **ppid** (chr): subject id (e.g., "VME_S09")
* **trial_num** (num): index of the trial in the experiment (includes all trials from all blocks; also training)
    "perception" block: 11-82  
    vSTM block ("experiment"): 93-812  
* **block_num** (num): index of the block 
* **c_StimN** (num): number of memory items (2 or 4)  
* **c_Ecc** (num): stimulus eccentricity (4, 9, 14)  
* **c_ResponseCorrect** (logi): correctness of response in this trial  
* **c_ResponseTime** (num): RT  
* **BlockStyle** (chr): denotes if trial was in "perception" or vSTM ("experiment") block  
* **CDA_amp_<cluster/fixed>times** (num): avg. CDA amplitude in this trial (see paper for spec. of ROI and time window). 
* **PNP_amp_<cluster/fixed>times** (num): avg. PNP amplitude in this trial (see paper for spec. of ROI and time window)
* **alphapwr_diff_retent** (num): avg. lateralized alpha power in this trial (see paper for spec. of freq. band, ROI and time window)
  

```{r init, message=FALSE, warning=FALSE, echo=TRUE}

#--------------------------------------------------------------------------
# Run main script for analysis for:
#  vMemEcc
#--------------------------------------------------------------------------

library(here)
library(knitr)


#--------------------------------------------------------------------------
# Define pathes
path_global 	    <- here('../..')
path_r_data       <- file.path(path_global, 'Data/DataR')
path_scripts_sven <- file.path(here('Workflow_Sven', 
                                    'osf_experiment1', 
                                    '_RScripts'))
path_extracted_vars <- file.path(here('../VME_extracted_vars.json'))
  # path_global, 'Writing', 
  #                            'Other', 
  #                            'VME_extracted_vars.json')

#--------------------------------------------------------------------------
## load packages & custom utils:
source(here("Utils", "load_packages.R"))
source(here('Utils', 'print_output.R'))
source(here('Utils', 'utils_report.R'))
source(here('Utils', 'calc_conf_intervalls.R'))


#--------------------------------------------------------------------------

#--------------------------------------------------------------------------
## define colors
source(file.path(path_scripts_sven, "loadColors.R"))
#--------------------------------------------------------------------------

#--------------------------------------------------------------------------
## load function to compute confidence intervals
source(file.path(path_scripts_sven,"loadFunctions.R"))
source(file.path(here('Utils', 'load_functions.R')))
#--------------------------------------------------------------------------

#--------------------------------------------------------------------------
## load theme
source(file.path(path_scripts_sven, "loadTheme.R"))
#--------------------------------------------------------------------------

#--------------------------------------------------------------------------
## load data, assign names for columns and define variable type
source(file.path(here('Utils', 'load_data.R')))
#--------------------------------------------------------------------------


# Write 
extract_var("r_version", "v4.1.0", exp_format = "%s")
extract_var("rstudio_version", "v1.4.1717", exp_format = "%s")

```

## Summary stats: 
**Extract relevants descriptives about the data set.**
```{r, desc stats}
# Total number of experimental trials (720 x n):

n_rej_subs <- 3
print(str_glue("N rejected subjects: {n_rej_subs}"))
n_subs_analyzed <- length(unique(data_behav$ppid))
n_tot_trials <- 720 * (n_subs_analyzed + n_rej_subs)
n_tot_trials_prerej <- 720 * n_subs_analyzed
print(str_glue("Total number of recorded experimental trials (720 x {n_subs_analyzed + n_rej_subs}): {n_tot_trials}"))
print(str_glue("Total number of experimental trials after subject rejection (720 x {n_subs_analyzed}): {n_tot_trials_prerej}"))
n_tot_trials_postrej <- data_behav %>% filter(BlockStyle == 'experiment') %>%  drop_na() %>% nrow()
n_trials_rejected <- n_tot_trials_prerej - n_tot_trials_postrej
print(str_glue("Total number of trials after rejection: {n_tot_trials_postrej} ({n_trials_rejected} trials rejected)"))

data_behav_per_task <- vector(mode = "list", length = 2)
data_behav_per_task[['exp']] <- data_behav %>% 
  filter(BlockStyle == 'experiment') %>%  
  drop_na() %>% 
  group_by(ppid, c_StimN, c_Ecc) %>%  
  mutate(dprime = qnorm(mean(c(Hit, 0.5))) - qnorm(mean(c(FalseAlarm, 0.5)))) %>% 
  ungroup()



data_behav_per_task[['perc']] <- data_behav %>% 
  filter(BlockStyle == 'perception') %>%  
  # select(!contains(c('CDA_amp', 'PNP_amp', 'alphapwr_diff_retent'))) %>% 
  select(ppid, trial_num, block_num, c_StimN, c_Ecc, c_ResponseCorrect, c_ResponseTime, BlockStyle, Hit, FalseAlarm, CorrRej, Miss) %>% 
  drop_na() %>% 
  group_by(ppid, c_StimN, c_Ecc) %>%  
  mutate(dprime = qnorm(mean(c(Hit, 0.5))) - qnorm(mean(c(FalseAlarm, 0.5)))) %>% 
  ungroup()


# Summary remaining trials:
summary_rem_trials_per_sub <- data_behav_per_task[['exp']] %>% 
  group_by(ppid) %>% 
  summarise(n_trials_remaining = n(), 
            perc_trials_remaining = n_trials_remaining*100 / 720, 
            .groups = "drop")



print(str_glue("Remaining trials per subject (percentage):
           mean: {mean(summary_rem_trials_per_sub$n_trials_remaining)} ({format(mean(summary_rem_trials_per_sub$perc_trials_remaining), digits=3)}%)
           range:  {min(summary_rem_trials_per_sub$n_trials_remaining)} ({format(min(summary_rem_trials_per_sub$perc_trials_remaining), digits=3)}%) - {max(summary_rem_trials_per_sub$n_trials_remaining)} ({format(max(summary_rem_trials_per_sub$perc_trials_remaining), digits=3)}%)\n\n"))

acc_overall <- vector(mode = "list", length = 2)
stats_overall <- vector(mode = "list", length = 2)
acc_per_memLoad <- vector(mode = "list", length = 2)
stats_memLoad <- vector(mode = "list", length = 2)
acc_per_ecc <- vector(mode = "list", length = 2)
stats_ecc <- vector(mode = "list", length = 2)


for (task in c('perc', 'exp')) {
  
  if (task == "exp") {
    outvars <- list("c_ResponseCorrect", 
                    "dprime",
                    "CDA_amp_clustertimes", 
                    "PNP_amp_clustertimes",
                    "alphapwr_diff_retent",
                    "maxDecodScore_sensorspace",
                    "maxDecodScoreTime_sensorspace",
                    "maxDecodScore_csp",
                    "maxDecodScoreTime_csp")
  } else {
    outvars <- list("c_ResponseCorrect", "dprime")
  }
  
  for (outvar in outvars) {
    
    scaler = switch (outvar,
                     "c_ResponseCorrect" = 100,
                     "alphapwr_diff_retent" = 1e12,
                     "maxDecodScoreTime_sensorspace" = 1000,
                     "maxDecodScoreTime_csp" = 1000,
                     1
                    )
    dv_str = switch (outvar,
                 "c_ResponseCorrect" = "mem_acc",
                 "dprime" = "dprime",
                 "alphapwr_diff_retent" = "alphalat",
                 "CDA_amp_clustertimes" = "cda",
                 "PNP_amp_clustertimes" = "pnp",
                 "maxDecodScore_sensorspace" = "decod_sensorspace_maxscore",
                 "maxDecodScoreTime_sensorspace" = "decod_sensorspace_maxscoretime",
                 "maxDecodScore_csp" = "decod_csp_maxscore",
                 "maxDecodScoreTime_csp" = "decod_csp_maxscoretime"
                )
      
    
    task_print <- if_else(task == "exp", "vSTM", "perception")
    print("#####################################################")
    print(str_glue("####  TASK: {task_print}"))
    print("#####################################################")
    
    
    # Summary accuracy overall:
    tmp <- data_behav_per_task[[task]] %>% 
      group_by(ppid) %>% 
      summarise(perc_resp_corr = mean(get(outvar)) * scaler, 
                .groups = "drop"
                ) %>% 
      ungroup() %>% 
      select(!ppid) 
    
    # Here we cannot calculate Cousineau-Morey CIs, so we take normal CIs:
    acc_overall[[task]][[outvar]] <- tmp %>% 
      summarise_all(list (mean = mean, sd = sd, min = min, max = max, ci95lower = ci95lower, ci95upper = ci95upper))
    
    rm(tmp)
    
    stats_overall[[task]][[outvar]] <- list(
      name = "overall", 
      printName = "overall", 
      levels = c(""),
      stats = acc_overall[[task]][[outvar]]
    )
    
    
    # Summary per Memory Load:
    tmp <- data_behav_per_task[[task]] %>% 
      group_by(ppid, c_StimN) %>% 
      summarise(perc_resp_corr = mean(get(outvar)) * scaler, 
                .groups = "drop") %>% 
      pivot_wider(names_from = c_StimN, 
                  values_from = perc_resp_corr, 
                  names_prefix = "StimN_") %>% 
      ungroup() %>% 
      select(!ppid) 
    
    acc_per_memLoad[[task]][[outvar]] <- tmp %>% 
      summarise_all(list (mean = mean, sd = sd, min = min, max = max, ci95lower = ci95lower, ci95upper = ci95upper))
    
    # Add Cousineau-Morey CIs:
    cmci95 <- cm.ci(tmp, difference = TRUE, conf.level = 0.95)
    
    for (l in colnames(tmp)) {
      for (bound in c("lower", "upper")) {
        acc_per_memLoad[[task]][[outvar]][1, str_c(l, '_cmci95', bound)] <- cmci95[rownames(cmci95)==l, colnames(cmci95)==bound]
      }
    }
    
    rm(cmci95, tmp)
    
    stats_memLoad[[task]][[outvar]] <- list(
      name = "StimN", 
      printName = "memLoad", 
      levels = str_c("StimN_", unique(data_behav_per_task[[task]]$c_StimN), '_'),
      stats = acc_per_memLoad[[task]][[outvar]]
    )
    
    
    # Summary per Ecc:
    tmp <- data_behav_per_task[[task]] %>% 
      group_by(ppid, c_Ecc) %>% 
      summarise(perc_resp_corr = mean(get(outvar)) * scaler,
                .groups = "drop") %>% 
      pivot_wider(names_from = c_Ecc, 
                  values_from = perc_resp_corr, 
                  names_prefix = "Ecc_") %>% 
      ungroup() %>% 
      select(!ppid) 
    
    acc_per_ecc[[task]][[outvar]] <- tmp %>% 
      summarise_all(list (mean = mean, sd = sd, min = min, max = max, ci95lower = ci95lower, ci95upper = ci95upper))
    
    # Add Cousineau-Morey CIs:
    cmci95 <- cm.ci(tmp, difference = TRUE, conf.level = 0.95)
    
    for (l in colnames(tmp)) {
      for (bound in c("lower", "upper")) {
        acc_per_ecc[[task]][[outvar]][1, str_c(l, '_cmci95', bound)] <- cmci95[rownames(cmci95)==l, colnames(cmci95)==bound]
      }
    }
    
    rm(cmci95, tmp)
    
    stats_ecc[[task]][[outvar]] <- list(
      name = "ecc", 
      printName = "Ecc", 
      levels = str_c("Ecc_", sort(unique(data_behav_per_task[[task]]$c_Ecc)), '_'), 
      stats = acc_per_ecc[[task]][[outvar]]
    )
  
    print("       **********************************************")
    print(str_glue("       ******  Dep. varibale: {outvar}"))
    print("       **********************************************")
    
    
    
    for (tmp in list(stats_overall[[task]][[outvar]], stats_memLoad[[task]][[outvar]], stats_ecc[[task]][[outvar]])) {
    
      print(str_glue("DV ({if_else(str_detect(tmp$printName, 'overall'), '', 'by ')}{tmp$printName}):\n"))
      for (lvl in tmp$levels) {
        if (length(tmp$levels) > 1) print(str_glue("{tmp$printName} == {parse_number(lvl)}:"))
        print(str_glue("    mean  (%): {tmp$stats[str_c(lvl, 'mean')]}"))
        print(str_glue("    SD    (%): {tmp$stats[str_c(lvl, 'sd')]}"))
        print(str_glue("    min   (%): {tmp$stats[str_c(lvl, 'min')]}"))
        print(str_glue("    max   (%): {tmp$stats[str_c(lvl, 'max')]}"))
        print(str_glue("    95% CI(%): {tmp$stats[str_c(lvl, 'ci95lower')]} - {tmp$stats[str_c(lvl, 'ci95upper')]}"))
        if (tmp$name != "overall") {
          print(str_glue("    95% Cousineau-Morey CI(%): {tmp$stats[str_c(lvl, 'cmci95lower')]} - {tmp$stats[str_c(lvl, 'cmci95upper')]}"))
        }
        
      }
      cat("\n\n")
    }
    
    ## Pairwise differences of the mean (with regular CIs):
    
    tmp_df <- data_behav_per_task[[task]] %>% 
      group_by(ppid, c_StimN) %>% 
      summarise(perc_resp_corr = mean(get(outvar)) * scaler, 
                .groups = "drop") %>% 
      pivot_wider(names_from = c_StimN, 
                 values_from = perc_resp_corr, 
                 names_prefix = "StimN_",
                 id_cols = ppid) %>%
      mutate(diff = StimN_2 - StimN_4) %>% 
      ungroup() %>% 
      select(!ppid) %>% 
      summarise_all(.funs = c(mean=mean, sd=sd, ci95lower=ci95lower, ci95upper=ci95upper))
    
    
    print("Difference between Memory Load conditions:")
    print(str_glue("  Mean (CI):     {format(tmp_df$diff_mean, digits=3)} ({format(tmp_df$diff_ci95lower, digits=3)} - {format(tmp_df$diff_ci95upper, digits=3)})"))
    
    extract_var(str_glue("{dv_str}_{task}_delta_StimN2vsStimN4_mean"), tmp_df$diff_mean, exp_format="%.2f")
    extract_var(str_glue("{dv_str}_{task}_delta_StimN2vsStimN4_cilower"), tmp_df$diff_ci95lower, exp_format="%.2f")
    extract_var(str_glue("{dv_str}_{task}_delta_StimN2vsStimN4_ciupper"), tmp_df$diff_ci95upper, exp_format="%.2f")
    
    cat("\n\n")
    
    
    tmp_df <- data_behav_per_task[[task]] %>% 
      group_by(ppid, c_Ecc) %>% 
      summarise(perc_resp_corr = mean(get(outvar)) * scaler, 
                .groups = "drop") %>% 
      pivot_wider(names_from = c_Ecc, 
                 values_from = perc_resp_corr, 
                 names_prefix = "Ecc_",
                 id_cols = ppid) %>% 
      mutate(diff_Ecc4vsEcc9 = Ecc_4 - Ecc_9,
             diff_Ecc4vsEcc14 = Ecc_4 - Ecc_14,
             diff_Ecc9vsEcc14 = Ecc_9 - Ecc_14) %>% 
      ungroup() %>% 
      select(!ppid) %>% 
      summarise_all(.funs = c(mean=mean, 
                              sd=sd, 
                              ci95lower=ci95lower, 
                              ci95upper=ci95upper, 
                              t_stat_t= ~ summarize_ttest(x = ., returnval = "t"), 
                              t_stat_p= ~ summarize_ttest(x = ., returnval = "p")))
    
    print("Difference between Eccentricity conditions:")
    contrast_pairs <- list(c("4", "9"), c("4", "14"), c("9", "14"))
    for (cp in contrast_pairs) {
      

      print(str_glue("  Contrast: {cp[1]} - {cp[2]}"))
      print(str_glue(".    Mean (%):     {format(tmp_df[[str_glue('diff_Ecc', cp[1], 'vsEcc', cp[2], '_mean')]], digits=3)}
                      .    CI (%):       ({format(tmp_df[[str_glue('diff_Ecc', cp[1], 'vsEcc', cp[2], '_ci95lower')]], digits=3)} - {format(tmp_df[[str_glue('diff_Ecc', cp[1], 'vsEcc', cp[2], '_ci95upper')]], digits=3)})"))
      
      extract_var(str_glue("{dv_str}_{task}_delta_Ecc{cp[1]}vsEcc{cp[2]}_mean"), tmp_df[[str_glue('diff_Ecc', cp[1], 'vsEcc', cp[2], '_mean')]], exp_format="%.2f")
      extract_var(str_glue("{dv_str}_{task}_delta_Ecc{cp[1]}vsEcc{cp[2]}_cilower"), tmp_df[[str_glue('diff_Ecc', cp[1], 'vsEcc', cp[2], '_ci95lower')]], exp_format="%.2f")
      extract_var(str_glue("{dv_str}_{task}_delta_Ecc{cp[1]}vsEcc{cp[2]}_ciupper"), tmp_df[[str_glue('diff_Ecc', cp[1], 'vsEcc', cp[2], '_ci95upper')]], exp_format="%.2f")
      extract_var(str_glue("{dv_str}_{task}_delta_Ecc{cp[1]}vsEcc{cp[2]}_t"), tmp_df[[str_glue('diff_Ecc', cp[1], 'vsEcc', cp[2], '_t_stat_t')]], exp_format="%.2f")
      extract_var(str_glue("{dv_str}_{task}_delta_Ecc{cp[1]}vsEcc{cp[2]}_p"), tmp_df[[str_glue('diff_Ecc', cp[1], 'vsEcc', cp[2], '_t_stat_p')]], exp_format="%.3f", is_pval = TRUE)
    }
    
    cat("\n\n")
  }
}         

extract_var("n_rej_subs", n_rej_subs, exp_format = "%i")
extract_var("n_tot_trials_prerej_allsubs", 720 * (n_subs_analyzed + n_rej_subs), exp_format = "%i")
extract_var("n_subs_analyzed", n_subs_analyzed, exp_format = "%i")
extract_var("n_tot_trials_prerej", n_tot_trials_prerej, exp_format = "%i")
extract_var("n_trials_rejected", n_tot_trials_prerej - n_tot_trials_postrej, exp_format = "%i")
extract_var("n_tot_trials_postrej", n_tot_trials_postrej, exp_format = "%i")
extract_var("avg_n_trials_per_sub_postrej", mean(summary_rem_trials_per_sub$n_trials_remaining), exp_format="%.2f")
extract_var("min_n_trials_per_sub_postrej", min(summary_rem_trials_per_sub$n_trials_remaining), exp_format="%i")
extract_var("max_n_trials_per_sub_postrej", max(summary_rem_trials_per_sub$n_trials_remaining), exp_format="%i")
extract_var("avg_perc_trials_per_sub_postrej", mean(summary_rem_trials_per_sub$perc_trials_remaining), exp_format="%.2f")
extract_var("min_perc_trials_per_sub_postrej", min(summary_rem_trials_per_sub$perc_trials_remaining), exp_format="%.2f")
extract_var("max_perc_trials_per_sub_postrej", max(summary_rem_trials_per_sub$perc_trials_remaining), exp_format="%.2f")

for(task in c("exp", "perc")) {
  if (task == "exp") {
    outvars <- list("c_ResponseCorrect",
                    "dprime",
                "CDA_amp_clustertimes", 
                "PNP_amp_clustertimes",
                "alphapwr_diff_retent",
                "maxDecodScore_sensorspace",
                "maxDecodScoreTime_sensorspace",
                "maxDecodScore_csp",
                "maxDecodScoreTime_csp")
  } else {
    outvars <- list("c_ResponseCorrect", "dprime")
  }
  for (outvar in outvars) {
    dv_str = switch (outvar,
             "c_ResponseCorrect" = "mem_acc",
             "dprime" = "dprime",
             "alphapwr_diff_retent" = "alphalat",
             "CDA_amp_clustertimes" = "cda",
             "PNP_amp_clustertimes" = "pnp",
             "maxDecodScore_sensorspace" = "decod_sensorspace_maxscore",
             "maxDecodScoreTime_sensorspace" = "decod_sensorspace_maxscoretime",
             "maxDecodScore_csp" = "decod_csp_maxscore",
             "maxDecodScoreTime_csp" = "decod_csp_maxscoretime"
            )
    for (tmp in list(stats_overall[[task]][[outvar]], stats_memLoad[[task]][[outvar]], stats_ecc[[task]][[outvar]])) {
      for (lvl in tmp$levels) {
        for (stat in c("mean", "sd", "min", "max", "ci95lower", "ci95upper", "cmci95lower", "cmci95upper")) {
          # for the grand average, we skip the Cousineau-Morey CIs (as we could not calculate them):
          if (tmp$name == "overall" && str_detect(stat, "cmci")) {
            next
          }
          extract_var(str_glue("{dv_str}_{task}_{lvl}{stat}"), tmp$stats[str_c(lvl, stat)], exp_format="%.2f")
        }
      }
    }
  }
}


```


## Analysis 01: 
**Is there an effect of workload or eccentricity on performance in the VSTM task and in the perception task?**

### VSTM Task:
_show source:_ 
```{r, echo=FALSE}
# Code to chunk:
insert_fun("func_analysis_01")
```
```{r func_analysis_01-source, eval = FALSE}
```

```{r, message=FALSE, warning=FALSE}
# VSTM task:
results_anova_behav_exp <- func_analysis_01('experiment')
```

_extract variables:_ 
```{r, echo=FALSE}
for (eff in c("c_StimN", "c_Ecc", "c_StimN:c_Ecc")) {
  eff_print <- eff %>% 
    str_replace_all("c_", "") %>% 
    str_replace_all(":", "x") 
    
  extract_var(str_c("anova_behav_exp_eff_", eff_print, "_F"), summary(results_anova_behav_exp$aov.srt)[[str_c("Error: ppid:", eff)]][[1]][[eff, "F value"]])
  extract_var(str_c("anova_behav_exp_eff_", eff_print, "_df_within"), summary(results_anova_behav_exp$aov.srt)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_behav_exp_eff_", eff_print, "_df_resid"), summary(results_anova_behav_exp$aov.srt)[[str_c("Error: ppid:", eff)]][[1]][["Residuals", "Df"]],
              exp_format = "%i")
  extract_var(str_c("anova_behav_exp_eff_", eff_print, "_p"), summary(results_anova_behav_exp$aov.srt)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Pr(>F)"]], 
              is_pval = TRUE, 
              exp_format = "%.3f")
}


```



### Perception task:
```{r,  message=FALSE, warning=FALSE}
# perceptual Change Detection Task:
results_anova_behav_perc <- func_analysis_01('perception')
```

```{r func_analysis_01-source, eval = FALSE}
```

_extract variables:_ 
```{r, echo=FALSE}
for (eff in c("c_StimN", "c_Ecc", "c_StimN:c_Ecc")) {
  eff_print <- eff %>% 
    str_replace_all("c_", "") %>% 
    str_replace_all(":", "x") 
    
  extract_var(str_c("anova_behav_perc_eff_", eff_print, "_F"), summary(results_anova_behav_perc$aov.srt)[[str_c("Error: ppid:", eff)]][[1]][[eff, "F value"]])
  extract_var(str_c("anova_behav_perc_eff_", eff_print, "_df_within"), summary(results_anova_behav_perc$aov.srt)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_behav_perc_eff_", eff_print, "_df_resid"), summary(results_anova_behav_perc$aov.srt)[[str_c("Error: ppid:", eff)]][[1]][["Residuals", "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_behav_perc_eff_", eff_print, "_p"), summary(results_anova_behav_perc$aov.srt)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Pr(>F)"]], 
              is_pval = TRUE, 
              exp_format = "%.3f")
}
```

## Analysis 01 - supplement I:
**Are the effects different, if we use a bias-corrected measure of change detection performance (here: d')?**
### VSTM Task:
```{r, message=FALSE, warning=FALSE}
# VSTM task:
results_anova_behav_dprime_exp <- func_analysis_01.1('experiment')
```

_extract variables:_ 
```{r, echo=FALSE}
for (eff in c("c_StimN", "c_Ecc", "c_StimN:c_Ecc")) {
  eff_print <- eff %>% 
    str_replace_all("c_", "") %>% 
    str_replace_all(":", "x") 
    
  extract_var(str_c("anova_behav_dprime_exp_eff_", eff_print, "_F"), summary(results_anova_behav_dprime_exp$aov.srt)[[str_c("Error: ppid:", eff)]][[1]][[eff, "F value"]])
  extract_var(str_c("anova_behav_dprime_exp_eff_", eff_print, "_df_within"), summary(results_anova_behav_dprime_exp$aov.srt)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_behav_dprime_exp_eff_", eff_print, "_df_resid"), summary(results_anova_behav_dprime_exp$aov.srt)[[str_c("Error: ppid:", eff)]][[1]][["Residuals", "Df"]],
              exp_format = "%i")
  extract_var(str_c("anova_behav_dprime_exp_eff_", eff_print, "_p"), summary(results_anova_behav_dprime_exp$aov.srt)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Pr(>F)"]], 
              is_pval = TRUE, 
              exp_format = "%.3f")
}


```

### Perception Task:
```{r, message=FALSE, warning=FALSE}
# Perception task:
results_anova_behav_dprime_perc <- func_analysis_01.1('perception')
```
_extract variables:_ 
```{r, echo=FALSE}
for (eff in c("c_StimN", "c_Ecc", "c_StimN:c_Ecc")) {
  eff_print <- eff %>% 
    str_replace_all("c_", "") %>% 
    str_replace_all(":", "x") 
    
  extract_var(str_c("anova_behav_dprime_perc_eff_", eff_print, "_F"), summary(results_anova_behav_dprime_perc$aov.srt)[[str_c("Error: ppid:", eff)]][[1]][[eff, "F value"]])
  extract_var(str_c("anova_behav_dprime_perc_eff_", eff_print, "_df_within"), summary(results_anova_behav_dprime_perc$aov.srt)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_behav_dprime_perc_eff_", eff_print, "_df_resid"), summary(results_anova_behav_dprime_perc$aov.srt)[[str_c("Error: ppid:", eff)]][[1]][["Residuals", "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_behav_dprime_perc_eff_", eff_print, "_p"), summary(results_anova_behav_dprime_perc$aov.srt)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Pr(>F)"]], 
              is_pval = TRUE, 
              exp_format = "%.3f")
}
```



## Analysis 01 - supplement II: 
**Is there an effect of workload or eccentricity on RT in the VSTM task and in the perception task?**  
This analysis was only conducted to exclude that a speed-acc trade-off is taking place. As we did not instruct participants to answer as fast as possible and due to imprecise temporal measurements of RTs with the VR hard- and software, we do not report this analysis in the paper. 

### VSTM Task:
```{r, message=FALSE, warning=FALSE}
# VSTM task:
func_analysis_03('experiment')
```

### Perception Task:
```{r, message=FALSE, warning=FALSE}
# perceptual Change Detection Task:
func_analysis_03('perception')
```


## Analysis 02: 
**Is there an effect of workload or eccentricity on mean CDA amplitude in the VSTM task?**

### CDA amplitude (rmANOVA):
```{r, message=FALSE, warning=FALSE}
results_anova_cda <- func_analysis_05(dep_variable = "CDA_amp_clustertimes")
```

_show source:_ 
```{r, echo=FALSE}
# Code to chunk:
insert_fun("func_analysis_05")
```
```{r func_analysis_05-source, eval = FALSE}
```

_extract variables:_ 
```{r, echo=FALSE}
for (eff in c("c_StimN", "c_Ecc", "c_StimN:c_Ecc")) {
  eff_print <- eff %>% 
    str_replace_all("c_", "") %>% 
    str_replace_all(":", "x") 
  
  # TODO: it's really ugly to split up the exports between here and the function call. I feel bad but will change this only in future projects.
  extract_var(str_c("anova_cda_eff_", eff_print, "_F"), summary(results_anova_cda)[[str_c("Error: ppid:", eff)]][[1]][[eff, "F value"]])
  extract_var(str_c("anova_cda_eff_", eff_print, "_df_within"), summary(results_anova_cda)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_cda_eff_", eff_print, "_df_resid"), summary(results_anova_cda)[[str_c("Error: ppid:", eff)]][[1]][["Residuals", "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_cda_eff_", eff_print, "_p"), summary(results_anova_cda)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Pr(>F)"]], 
              is_pval = TRUE, 
              exp_format = "%.3f")
}
```


### Analysis 02 - Supplement 1: CDA amplitude (lmer):
A multilevel model confirms the results of the rmANOVA:

```{r, message=FALSE, warning=FALSE}
m1 <- func_analysis_07('experiment', dep_variable = 'CDA_amp_clustertimes')
print(summary(m1))
summary_df <- data.frame(coef(summary(m1)))
ci_df <- print_CI_lmer(m1)
summary_df <- merge(summary_df, ci_df, by = 0)
summary_df[, -c(1, 6)] <- round(summary_df[, -c(1, 6)], 2)
# round p-value to 3 digits:
summary_df[, 6] <- round(summary_df[, 6], 3)
summary_df$ci_formatted <- sprintf("[%.2f; %.2f]", summary_df$lower, summary_df$upper)
print(summary_df)
```

_show source:_ 
```{r, echo=FALSE}
# Code to chunk:
insert_fun("func_analysis_07")
```
```{r func_analysis_07-source, eval = FALSE}
```

### Analysis 02 - Supplement 2: CDA amplitude (a priori time window):
Same as the main CDA analysis (ANOVA) but this time on the mean CDA amplitude in the time winow taken from the literature (Hakim et al., 2019):

```{r, message=FALSE, warning=FALSE}
results_anova_cda_fixedtimes <- func_analysis_05(dep_variable = "CDA_amp_fixedtimes")
```

_extract variables:_ 
```{r, echo=FALSE}
for (eff in c("c_StimN", "c_Ecc", "c_StimN:c_Ecc")) {
  eff_print <- eff %>% 
    str_replace_all("c_", "") %>% 
    str_replace_all(":", "x") 
  
  # TODO: it's really ugly to split up the exports between here and the function call. I feel bad but will change this only in future projects.
  extract_var(str_c("anova_cda_fixedtimes_eff_", eff_print, "_F"), summary(results_anova_cda_fixedtimes)[[str_c("Error: ppid:", eff)]][[1]][[eff, "F value"]])
  extract_var(str_c("anova_cda_fixedtimes_eff_", eff_print, "_df_within"), summary(results_anova_cda_fixedtimes)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_cda_fixedtimes_eff_", eff_print, "_df_resid"), summary(results_anova_cda_fixedtimes)[[str_c("Error: ppid:", eff)]][[1]][["Residuals", "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_cda_fixedtimes_eff_", eff_print, "_p"), summary(results_anova_cda_fixedtimes)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Pr(>F)"]], 
              is_pval = TRUE, 
              exp_format = "%.3f")
}
```


### Analysis 02 - Supplement 3: CDA amplitude (a priori time-window -- lmer):
A multilevel model confirms the results of the original rmANOVA:

```{r, message=FALSE, warning=FALSE}
m1 <- func_analysis_07('experiment', dep_variable = 'CDA_amp_fixedtimes')
print(summary(m1))
summary_df <- data.frame(coef(summary(m1)))
ci_df <- print_CI_lmer(m1)
summary_df <- merge(summary_df, ci_df, by = 0)
summary_df[, -c(1, 6)] <- round(summary_df[, -c(1, 6)], 2)
# round p-value to 3 digits:
summary_df[, 6] <- round(summary_df[, 6], 3)
summary_df$ci_formatted <- sprintf("[%.2f; %.2f]", summary_df$lower, summary_df$upper)
print(summary_df[, c(1, 2, 5, 4, 9, 6, 3, 7, 8)])
```


### Analysis 03: PNP amplitude (rmANOVA):
Testing the effects of _memory load_ and _eccentricity_ on the mean **PNP amplitude** (see [Papaioannou & Luck, 2020](https://onlinelibrary.wiley.com/doi/abs/10.1111/psyp.13532))

```{r, message=FALSE, warning=FALSE}
results_anova_pnp <- func_analysis_09(dep_variable = "PNP_amp_clustertimes")
```

```{r, echo=FALSE}
for (eff in c("c_StimN", "c_Ecc", "c_StimN:c_Ecc")) {
  eff_print <- eff %>% 
    str_replace_all("c_", "") %>% 
    str_replace_all(":", "x") 
    
  extract_var(str_c("anova_pnp_eff_", eff_print, "_F"), summary(results_anova_pnp)[[str_c("Error: ppid:", eff)]][[1]][[eff, "F value"]])
  extract_var(str_c("anova_pnp_eff_", eff_print, "_df_within"), summary(results_anova_pnp)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_pnp_eff_", eff_print, "_df_resid"), summary(results_anova_pnp)[[str_c("Error: ppid:", eff)]][[1]][["Residuals", "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_pnp_eff_", eff_print, "_p"), summary(results_anova_pnp)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Pr(>F)"]], 
              is_pval = TRUE, 
              exp_format = "%.3f")
}
```




## Analysis 04: 
**Is there an effect of workload or eccentricity on mean lateralized alpha power in the VSTM task?**
See paper for specifics of parameters re. frequency band, ROI, and time window that were used to calculate mean lateralized power (power **contralaterally - ipsilaterally**)

### lat. alpha power (rmANOVA):
```{r, message=FALSE, warning=FALSE}
results_anova_alphalat <- func_analysis_06()
```

_show source:_ 
```{r, echo=FALSE}
# Code to chunk:
insert_fun("func_analysis_06")
```
```{r func_analysis_06-source, eval = FALSE}
```

```{r, echo=FALSE}
for (eff in c("c_StimN", "c_Ecc", "c_StimN:c_Ecc")) {
  eff_print <- eff %>% 
    str_replace_all("c_", "") %>% 
    str_replace_all(":", "x") 
    
  extract_var(str_c("anova_alphalat_eff_", eff_print, "_F"), summary(results_anova_alphalat)[[str_c("Error: ppid:", eff)]][[1]][[eff, "F value"]])
  extract_var(str_c("anova_alphalat_eff_", eff_print, "_df_within"), summary(results_anova_alphalat)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_alphalat_eff_", eff_print, "_df_resid"), summary(results_anova_alphalat)[[str_c("Error: ppid:", eff)]][[1]][["Residuals", "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_alphalat_eff_", eff_print, "_p"), summary(results_anova_alphalat)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Pr(>F)"]], 
              is_pval = TRUE, 
              exp_format = "%.3f")
}
```

### Analysis 04 - Supplement 1: lat. alpha power (lmer):
A multilevel model confirms the results of the rmANOVA:

```{r, message=FALSE, warning=FALSE}
func_analysis_10('experiment', dep_variable = 'alpha_pwr')
```


## Analysis 05: 
**Is there an effect of stimulus eccentricity on the (max) decoding performance? 

### Sensor space decoding (rmANOVA):
```{r, message=FALSE, warning=FALSE}
results_anova_decod_ss <- func_analysis_12()
```

_show source:_ 
```{r, echo=FALSE}
# Code to chunk:
insert_fun("func_analysis_12")
```
```{r func_analysis_12-source, eval = FALSE}
```

```{r, echo=FALSE}
for (eff in c("c_Ecc")) {
  eff_print <- eff %>% 
    str_replace_all("c_", "") %>% 
    str_replace_all(":", "x") 
    
  extract_var(str_c("anova_decod_sensorspace_eff_", eff_print, "_F"), summary(results_anova_decod_ss)[[str_c("Error: ppid:", eff)]][[1]][[eff, "F value"]])
  extract_var(str_c("anova_decod_sensorspace_eff_", eff_print, "_df_within"), summary(results_anova_decod_ss)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_decod_sensorspace_eff_", eff_print, "_df_resid"), summary(results_anova_decod_ss)[[str_c("Error: ppid:", eff)]][[1]][["Residuals", "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_decod_sensorspace_eff_", eff_print, "_p"), summary(results_anova_decod_ss)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Pr(>F)"]], 
              is_pval = TRUE, 
              exp_format = "%.3f")
}
```



### CSP decoding (rmANOVA):
```{r, message=FALSE, warning=FALSE}
results_anova_decod_csp <- func_analysis_14()
```

_show source:_ 
```{r, echo=FALSE}
# Code to chunk:
insert_fun("func_analysis_14")
```
```{r func_analysis_14-source, eval = FALSE}
```

```{r, echo=FALSE}
for (eff in c("c_Ecc")) {
  eff_print <- eff %>% 
    str_replace_all("c_", "") %>% 
    str_replace_all(":", "x") 
    
  extract_var(str_c("anova_decod_csp_eff_", eff_print, "_F"), summary(results_anova_decod_csp)[[str_c("Error: ppid:", eff)]][[1]][[eff, "F value"]])
  extract_var(str_c("anova_decod_csp_eff_", eff_print, "_df_within"), summary(results_anova_decod_csp)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_decod_csp_eff_", eff_print, "_df_resid"), summary(results_anova_decod_csp)[[str_c("Error: ppid:", eff)]][[1]][["Residuals", "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_decod_csp_eff_", eff_print, "_p"), summary(results_anova_decod_csp)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Pr(>F)"]], 
              is_pval = TRUE, 
              exp_format = "%.3f")
}
```


## Analysis 05 - supplement: 
**Is there an effect of stimulus eccentricity on the time of the max. decoding performance? 

### Sensor space decoding (rmANOVA):
```{r, message=FALSE, warning=FALSE}
results_anova_decod_ss_time <- func_analysis_13()
```

_show source:_ 
```{r, echo=FALSE}
# Code to chunk:
insert_fun("func_analysis_13")
```
```{r func_analysis_13-source, eval = FALSE}
```

```{r, echo=FALSE}
for (eff in c("c_Ecc")) {
  eff_print <- eff %>% 
    str_replace_all("c_", "") %>% 
    str_replace_all(":", "x") 
    
  extract_var(str_c("anova_decod_time_sensorspace_eff_", eff_print, "_F"), summary(results_anova_decod_ss_time)[[str_c("Error: ppid:", eff)]][[1]][[eff, "F value"]])
  extract_var(str_c("anova_decod_time_sensorspace_eff_", eff_print, "_df_within"), summary(results_anova_decod_ss_time)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_decod_time_sensorspace_eff_", eff_print, "_df_resid"), summary(results_anova_decod_ss_time)[[str_c("Error: ppid:", eff)]][[1]][["Residuals", "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_decod_time_sensorspace_eff_", eff_print, "_p"), summary(results_anova_decod_ss_time)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Pr(>F)"]], 
              is_pval = TRUE, 
              exp_format = "%.3f")
}
```



### CSP decoding (rmANOVA):
```{r, message=FALSE, warning=FALSE}
results_anova_decod_csp_time <- func_analysis_15()
```

_show source:_ 
```{r, echo=FALSE}
# Code to chunk:
insert_fun("func_analysis_15")
```
```{r func_analysis_15-source, eval = FALSE}
```

```{r, echo=FALSE}
for (eff in c("c_Ecc")) {
  eff_print <- eff %>% 
    str_replace_all("c_", "") %>% 
    str_replace_all(":", "x") 
    
  extract_var(str_c("anova_decod_time_csp_eff_", eff_print, "_F"), summary(results_anova_decod_csp_time)[[str_c("Error: ppid:", eff)]][[1]][[eff, "F value"]])
  extract_var(str_c("anova_decod_time_csp_eff_", eff_print, "_df_within"), summary(results_anova_decod_csp_time)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_decod_time_csp_eff_", eff_print, "_df_resid"), summary(results_anova_decod_csp_time)[[str_c("Error: ppid:", eff)]][[1]][["Residuals", "Df"]], 
              exp_format = "%i")
  extract_var(str_c("anova_decod_time_csp_eff_", eff_print, "_p"), summary(results_anova_decod_csp_time)[[str_c("Error: ppid:", eff)]][[1]][[eff, "Pr(>F)"]], 
              is_pval = TRUE, 
              exp_format = "%.3f")
}
```


## Plot correlations:

```{r}
dcor <- data_behav %>% 
  filter(BlockStyle == 'experiment') %>% 
  select(-trial_num, -block_num, -c_StimN, -c_Ecc, -BlockStyle) %>% 
  group_by(ppid) %>% 
  summarise_all(.funs = c(mean = ~mean(., na.rm=TRUE))) %>% 
  ungroup() %>% 
  select(-ppid) 

Mcor <- cor(dcor, method="pearson")
Pcor <- cor.mtest(dcor, conf.level=0.95)


colnames(Mcor) = c("Mem. perf.", "RT", "CDA (our window)", "CDA (a priori window)", "PNP (our window)", "PNP (a priori window)",
                   "Lat. alpha pwr", "max. decod. perf. (broadband)", "Time of ^^^", "max. decod. perf. (alpha pwr)", "Time of ^^^")
rownames(Mcor) = colnames(Mcor)

fname = file.path(path_global, 'Plots2022', 'Else', 'CorrPlot_AllMeasures.pdf')
cm = 1 / 2.54
pdf(fname, height=12 * cm, width=12 * cm)
fig = corrplot(Mcor, type = 'lower', tl.cex = 0.7)  # , p.mat = Pcor$p, sig.level = 0.05)
dev.off()


```
### Rejected trials per eccentricity
```{r}

res <- func_analysis_16()

```



# Write out the full data frame:

```{r}

saveRDS(data_behav,file = file.path(path_r_data, "VME_trialdata.rds"))

variable_doc <- list()

variable_doc[["ppid"]] <- 
  "subject identifier"
variable_doc[["trial_num"]] <- 
  "trial number (1-10 & 83-92: training, 11-72: perception task, 93-812: vSTM task)"
variable_doc[["block_num"]] <- 
  "number of experimental block (1 & 3: training, 2: perception task, 4-13: vSTM task)"
variable_doc[["c_StimN"]] <- 
  "Memory Load (aka. number of memory stimuli)"
variable_doc[["c_Ecc"]] <- 
  "Eccentricity of the stimulus arrays (in dva)"
variable_doc[["c_ResponseCorrect"]] <- 
  "Correctness of response"
variable_doc[["c_ResponseTime"]] <- 
  "Response time"
variable_doc[["BlockStyle"]] <- 
  "Type of the block (perception task or vSTM task [experiment])"
variable_doc[["CDA_amp_clustertimes"]] <- 
  "Mean CDA amplitude, averaged across 5 ROI electrodes and timepoints when overall CDA was sign. different from 0 (as assessed by a CBP test)"
variable_doc[["PNP_amp_clustertimes"]] <- 
  "Mean PNP amplitude, averaged across 5 ROI electrodes and timepoints when overall PNP was sign. different from 0 (as assessed by a CBP test)"
variable_doc[["CDA_amp_fixedtimes"]] <- 
  "Mean CDA amplitude, averaged across 5 ROI electrodes and timepoints during the time window [0.4-1.45s] used by Hakim et al. (2019)"
variable_doc[["PNP_amp_fixedtimes"]] <- 
  "Mean CDA amplitude, averaged across 5 ROI electrodes and timepoints during the time window [0.3–0.444s] used by Papaioannou et al. (2020)"
variable_doc[["alphapwr_diff_retent"]] <- 
  "Mean induced alpha power difference (between hemispheres), averaged across 5 ROI electrodes and timepoints when overall alpha power lateralization was sign. different from 0 (as assessed by a CBP test)"
variable_doc[["alphapwr_diff_retent"]] <- 
  "Mean induced alpha power difference (between hemispheres), averaged across 5 ROI electrodes and timepoints when overall alpha power lateralization was sign. different from 0 (as assessed by a CBP test)"
variable_doc[["maxDecodScore_sensorspace"]] <- 
  "Highest decoding score achieved by the sliding classifier run on the voltage data. One score per eccentricity condition and subject (not per trial)."
variable_doc[["maxDecodScoreTime_sensorspace"]] <- 
  "Time (relativ to stimulus onset) of the highest decoding score achieved by the sliding classifier run on the voltage data. One score per eccentricity condition and subject (not per trial)."
variable_doc[["maxDecodScore_csp"]] <- 
  "Highest decoding score achieved by the sliding CSP classifier (classification in power space). One score per eccentricity condition and subject (not per trial)."
variable_doc[["maxDecodScore_csp"]] <- 
  "Time (relativ to stimulus onset) of the highest decoding score achieved by the sliding CSP classifier (classification in power space). One score per eccentricity condition and subject (not per trial)."



if ((length(names(variable_doc)) != length(colnames(data_behav))) | any(sort(names(variable_doc)) != sort(colnames(data_behav)))) {
  warning("The docu of the variables ('VME_trialdata__variables.json') might be incomplete or wrong.")
}

jsonlite::write_json(variable_doc, file.path(path_r_data, "VME_trialdata__variables.json"), pretty=TRUE)



```